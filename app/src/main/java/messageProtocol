MainType 0:系统消息
    SubType:0 登录验证
            1 推送好友列表
            2 要求推送离线消息
            3 添加好友请求
            4 好友验证反馈
            5.反馈接收成功的离线消息列表--content字段里为消息列表，用“，”分割

MainType 1:聊天信息-----区分群聊还是单聊看receive是List还是单个
    SubType：0 普通文本
             1 图片信息
             2 语音信息
             3 红包信息
             4

记录：
0.chatMessage 用于处理本地数据存取，IMessage用于网络传输，activity中不应出现IMessage
1.发送消息的协议需要把receiveId改成集合，依此判断是单聊还是群聊
以app端为驱动，后台需完善消息的发收人id,日期，内容，类型，在进聊天界面时 根据receiveId查找聊天记录，需要
判读是接收者还是发送者，左接右发,依据为比对发送者id和当前用户id
2.发送消息时 插入List并更新adapter-- 插入数据库（记录为未发送）--加入消息队列--收到回执（更新为已发送）
3.从数据库取出数据时不需要查找排序，在数据融合后再排序（在ChatMessage中添加比较方法）
4.聊天信息流向 根据类型组装IMessage-->转ChatMessage保存到数据库-->将步骤1中的IMessage送到WebSocketService
-->进入消息队列-->发送-->若成功 更改数据库中此信息发送状态-->通知聊天界面更新发送状态
5.接收离线聊天信息时注意 同一设备登录收发双方的情况，应判断是否重复插值 （解决方案：设备id）
6.头像返回url用Picasso异步加载
7.InformationFragment维护一个保存<发送人id,信息列表>的HashMap
8.由于离线消息为单条发送 所以需要添加结束信息通知 收到结束通知后再EventBus发送
9.关于消息（会话列表）先从数据库里读出所有的消息，只去最新的一条，归类（暂时只是聊天信息），然后同时发送 推送离线消息的请求，插到数据库
里，接收完成后通知会话列表刷新。
10.为了方便管理会话列表，需要新增一个表来记录，内容包括，最新的聊天信息id,聊天人
/****************用户表*****************************/
里面包括用户自己，和好友
字段：用户id,登录名，分组信息，头像url,
头像上传在服务器保存后 在数据库记录头像路径，并与消息回执一并返回，再通过http获取；

/****************ChatMessage*****************************/
2016/12/20 添加senderName和receiverName
/****************Session表*****************************/
1.里的unRead字段需要赋值给UserInfo，再在界面显示出来，当点击该会话进入聊天主界面时，UserInfo中的
和该行的unRead置“0”；
2.把系统消息也当做是UserInfo 一个特殊的


/****************后台*****************************/
1.规范service业务层和dao数据访问层。
2.IMessageFactory这文件所在包位置一定要和后台位置一致 否则导致反序列失败  websocket关闭码（1002）
3.2016-11-28 压力测试 消息发收状态确认,
